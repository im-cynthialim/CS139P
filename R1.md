# R1 - Reading Assignment

## A Swift Tour

### Simple Values
- var, let
- string

### Control Flow
- for
    - for i in 0..<4 to add a range that goes from 0 to 3
    - ... to include upper value
- while
- unwrap with if let

### Functions and Closures

```swift
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
```
- use _ to use no argument label
- can also customize arg labels, place before parameter name
- possible to return tuples
    - e.g. ... -> (min: Int, max: Int, sum: Int) {}
- nested functions can use variables declared in outer function
- functions can return functions

```swift
    func makeIncrementer() -> ((Int) -> Int) {
        func addOne(number: Int) -> Int {
            return 1 + number
        }
        return addOne // returning the function, not calling it
    }
    var increment = makeIncrementer()
    increment(7)
```
- functions can also take a function as an arg
- closures: blocks of code that can be call later
    - can access vars/funcs available in scope where it was created, even if caled elsewhere
    - closure without name: surround code with ({}):

        ```swift
            // map takes each element of numbers and applies the closure to it
            // e.g. numbers = [1, 2, 3], returns numers = [2, 4, 6]
            numbers.map({ (number: Int) -> Int in
                let result = 2 * number
                return result
            })
        ```
        - <mark>aside:</mark> map is a higher-order function
        - can omit params type and/or return type
            - single statement closures return the value implicitly
        - can refer to params using numbers ($0: first param, $1: second param)

### Objects and Classes
- use `init` as initializer for class:
    ```swift
    class NamedShape {
        // assign every property a value in declaration OR in initializer
        var numberOfSide: Int = 0
        var name: String

        init (name: String) {
            self.name = name
        } 

        func simpleDescription() -> String {
            return "A shape naemd \(name)"
        }
    }
    ```
- use `deinit` as deinitializer: for cleanup before object dealloc.

- subclass and superclass: `class Square: NamedShape`
    - can `override` superclass methods
- getters and setters:
    ```swift
        class EquilateralTriangle: NamedShape {
            ...
            var perimeter: Double {
                get {
                    // sideLength is a property of eqTriangle
                    return 3.0 * sideLength
                }
                set {
                    sideLength = newValue / 3.0
                }
                // alternatively, choose name for new value when setting:
                set (newNameHere) {
                    sideLength = newNameHere / 3.0
                }
            }
        }

        var triangle = eqTriangle(sideLength: 3.1, name: "")
        print(triangle.perimeter)
        // 9.3
        triangle.perimeter = 9.9
        print(triangle.sideLength)
        // 3.3
    ```
    - for code to run before/after setting value
        - `willSet` (before - implicit access to `newValue`)
        - `didSet` (after - implicit access to `oldValue`)
        e.g. triangle square example: `willSet` = "right before you update the square/triangle length, I'll update the other shape's side length to the incoming value so that they're the same"
    - optional values (`?`):
        - if value evalutes to nil, then everything after `?` is ignored, whole expr = nil
        - else deal with expr. as usual

### Enumerations and Structures
- enums can have methods associated to them
    - define cases at the top
    - set up switch method (`switch self`) within method for different cases
- default assignment of raw values, starting at 0 - can define explicity as well (`case ace = 1`)
    - can also use floating point/strings as `rawValue` type
- use `init?(rawValue: )` to create instance of enum from rawValue, returns enum case that mathces or nil if none
    - e.g.
    ```swift
    if let rank = Rank(rawValue: 3) {
        let threeDescription = rank.simpleDescription()
    }
    ```

- structs, similar to classes for methods + initializers
    - <mark> structs always copied vs. classes passed by reference </mark> 

### Generics
- similar to C++ template: general function/type that works with any type
    - achieve by placing name in `<>`
    - use `where` before body to specify reqs (e.g. require type for a protocol, require 2 types to be the same, require class to have certain superclass)
    - e.g.
        ```swift
        func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
            // verifying that T and U are comparable - that they're of the same type
            // in this case, this passes since [1, 2, 3] and [3] are both Int sequences
            where T.Element: Equatable, T.Element == U.Element
        {
                for lhsItem in lhs {
                    for rhsItem in rhs {
                        if lhsItem == rhsItem {
                            return true
                        }
                    }
                }
            return false
        }
        anyCommonElements([1, 2, 3], [3])
        ```

## The Basics

### Type Safety and Type Inference
- swift is type-safe
- values never implicitly converted from one type to another, but can convert explicitly
- type inference: compiler deduces type based on values given
- swift always uses Double over Float for floating point numbers

### Numeric Literals
- can write Integers as decimal (no prefix), binary (0b prefix), octal (0o prefix), hexadecimal (0x prefix)
- can use E/e for exponent with decimal
- can use P/p for exponent with hexadecimal (2^x, where x is the hexadecimal value)
- can pad ints/floats with zeros/underscores for legibility (0001.23, 1_000_000)

### Numeric Type Conversion
- Int8: -127 - 128
- UInt8: 0 - 255
- floating point to int conversion: value is truncated (3.75 -> 3)

### Tuples
- group multiple values into a single one, types don't have to be the same
- decompose tuples to use and access:

```swift
    let (code, msg) = httpserror
    // can now use code and msg
    // can also access as httpserror.0, httpserror.1
    // alternatively, name tuple values so that you can reference them
    let httpserror = (statusCode: "", statMsg: "")
    // can now use httpserror.statusCode and httpserror.statMsg
```
- ignore parts of tuple with _

## Basic Operators
### Range Operators
- closed range operators
    - `a...b`
        - a must be <= b
        - a to b inclusive

- half-open range operator
    - `a..<b`
        - [a, b)

- one-sided ranges
    - for arrays
    - starting index to end: [2...]
    - start to ending index: [...2]
    - can also apply half-open range: [..<2]
    ```swift
        let range = ...5
        // this DOESN'T start at 0
        range.contains(-1) // true
    ```

## Strings and Characters
- string literal: characters wrapped by `"` `"`
- multiline with `"""`
    - whitespace before closing `"""` indicates how much to be ignored on all other lines
- line break with `\`
- special characters: `\0`, `\\`, `\t`, `\n`, `\r`, `\"`, `\'`
- unicode: `\u{n}`, n is 1-8 digit hexadecimal number
- initialize with `String()` or `""`
- `.isEmpty`

### Counting Characters
- use `.count`

### Accessing and Modifying a String
- every string has an index type, use to access position of each Character
    - amount of memory can vary, so can't use integer vals for indices
    - `startIndex` for first char
    - `endIndex`, position after last char
    - use `before:` and `after:` to access other chars starting from start/end index
    - use `offsetBy:`
    ```swift
        let greeting = "asdfasdf"
        // first char
        greeting[greeting.startIndex]

        // last char
        greeting[greeting.index(before: greeting.endIndex)]

        // second char
        greeting[greeting.index(after: greeting.startIndex)]
        
        // start + 7
        let index = greeting.index(greeting.startIndex, offsetBy: 7)
        greeting[index]
    ```
    - use `.indices` to access all indices of chars of string

### Substrings
- substrings are similar to strings, but need to convert to `String` if using for longer
    - substr use the same memory as original string until converted to `String`


## Collection Types
- Swift provides 3 primary collection types: arrays, sets, and dictionaries

### Mutability of Collections
- assign collection to var = mutable
- assign to constant = immutable (size + contents can't change)

### Arrays
- write type as `Array<Element>`
    - shorthand form: `[Element]`

- Empty array
    - empty array literal: `[]`
    - via explicit initializer: `[Int]()`

- Default value
    - use initializer to define size and same default values
    - `var threeDoubles = Array(repeating: 0.0, count: 3) // [0.0, 0.0, 0.0]`

- can add 2 arrays together, second array gets appended to first
- array literal: shorthand to define array with 1+ values
    - `var shoppingList: [String] = ["Eggs", "Milk"]`
    - can also omit type - Swift has type inference

- number of items in array: `.count`
    - check if count == 0: `.isEmpty`

- add item with `.append(<newItem>)` or `arrayName += [<newItem>, <newItem2>]`
- use index to access/update array element
    - can also use range of indices to replace elements: `shoppingList[4...6] = ["", ""]`

- insert at specific index: `shoppingList.insert("yum", at: 0)`
- remove at specific index: `shoppingList.remove(at: 0)`
    - can remove last item of array with `.removeLast()`
    - note: both of these methods return the removed item

- iterating over array
    - use `for-in` loop
    - use `for (index, value) in shoppingList.enumerated()` if you need the index

### Dictionaries
- `Dictionary<Key, Value>`, shortform: `[Key: Value]`
    - Key has to conform to `Hashable`

- empty dictionary: 
    - initialize empty: `var newDictionary: [Int: String] = [:]`
    - set empty: `newDict = [:]`
- add key and value pair: `newDict[1] = "one"`
- initialize with dictionary literal: `var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]`
- number of items: `.count`, can use `.isEmpty`
- add/change item: `airports["LHR"] = "London"`
    - can also add/change with `.updateValue`:
        - this returns optional value, old value after update or `nil`
- remove item by setting value to `nil`
    - or use `.removeValue()`: `if let removedValue = airports.removeValue(forKey: "DUB")`
        - returns removed value if exists, else `nil`
- iterate over dictionary
        ```swift
        // use `for-in` with `(key, value)` tuple:
        for (airportCode, airportName) in airports {}
        
        // iterate over keys
        for airportCode in airports.keys {}

        // iterate over values 
        for airportName in airports.values {}

        // initialize array with keys/values
        let airportCode = [String](airports.keys)

        let airportNames = [String](airports.values)
        ```
- use `sorted()` to iterate over keys/values in an order

## Control Flow
### Switch
- every switch statement has be exhaustive
    - every possible value of the type has to match one of the cases
    - use `default` for values not addressed explicitly
- switch statements have an expression form, can use it on RHS of assignment:
    ```swift
    let message = switch ... {
        case "a": 
            "..."
        default: 
            "default"
        }
    print(message)
    ```
- can also throw an error/call a function

- switch doesn't have implicit fallthrough
    - doesn't fall through bottom of a case all the way to default
    - doesn't require explicit break statement
- body of each case needs at least one executable statement
- to match multiple values in single case:
    ```swift
    switch ... {
        case "a", "A":
            print("")
        default:
            print("")
    }
    ```

### Break
- break in loop/switch statement
    - ends loop + moves to code after loop/switch's closing brace

### Early Exit
- `guard` statement, like `if` statement, executes depending on Boolean value of an expression
    - use to require condition to be true to execute code after guard statement
    - vs. `if` statement, `guard` always has an `else` clause + improved readability

- any var/const assigned values in optional binding of condition can still be used in code block where the `guard` statement appears

## Functions
### Function Argument Labels and Parameter Names
- arg label used when calling function, parameter name used when implementing function
     - default arg label is param. name

- add arg label before param name:  `func someFunction(argumentLabel paramName: Int) {}`

e.g. 
```swift
func greet(person: String, from hometown: String) -> String {}

greet(person: "Bill", from: "Here")
```

- omit by using `_`: 
```swift
func someFunction (_ paramName: Int, paramTwo: Int) {}

someFunction (1, paramTwo: 2)
```

### Function Types
- can define var/const. to be function type + assign function to that var: `var mathFunc: (Int, Int) -> Int = addTwoInts`
    - e.g. defines var mathFunction which has the type of a function that takes in 2 Ints and returns an Int. `addTwoInts` has same type, so can call it using `mathFunction`: `print(\(mathFunction(2, 3)))`
- can also let Swift infer function type: `let anotherFunction = addTwoInts` 

- can use function type, like `(Int, Int) -> Int`, as parameter type for another function
e.g. 
```swift
func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \(mathFunction(a, b))")
}
printMathResult(addTwoInts, 3, 5)
// Prints "Result: 8"

// mathFunctioni is any type of math calculation that takes in 2 Ints and returns Int
```

- function type as return type
    - add after return arrow ( -> )
```swift
func fwd(_ input: Int) -> Int {
    return input + 1
}

func bwd(_ input: Int) -> Int {
    return input - 1
}

func chooseStepFn(backward: Bool) -> (Int) -> Int {
    return backward ? bwd : fwd
}
```

## Closures
- self-contained blocks of functionality, can be used in diff. places
    - can capture and store references to const/var from the context they're defined in (*closing over* the consts/vars)
- global/nested functions are special cases of closures
    - global func: closures with a name + don't capture any values
    - nested: closures with name + can capture values from enclosing function
    - closure expressions: unnammed closures that capture values from surrounding context

### Closure Expressions
- usually short function-like expr. without full decl. + name + takes 1+ func. as arg.
- to write inline closures, lightweight + brief syntax
- Swift has optimizations like:
    - infer param + return value types from context
    - implicit returns from single-expr. clossures
    - shorthand arg. names
    - trailing closure syntax

- sorted method
    - sorts array of values based on output of sorting closure that you provide
    - returns new array of same type + size but in sorted order
    - original array not modified
    - this method accepts a closure that takes in 2 arguments, returns Bool value that's true if first value should be before second value in sorted order
    e.g. to sort strings, closure would have type: (String, String) -> Bool

- closure expression syntax
    ```swift
    { (<#parameters#>) -> <#return type#> in
    <#statements#>
    }

    // e.g.
    reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
        return s1 > s2
    })
    ```

    - params can't have default value
    - variadic params can be used if you name it (variadic params: take in variable number of args)
    - tuples can be used for param + return type
    - start of closure's body is at `in`

    - type can be inferred
        - infers that `sorted` is called on array of strings, so type must be `(String, String) -> Bool`
        - simplify to: `reversedNames = names.sorted(by: {s1, s2 in return s1 > s2})`

    - implicit return from single-expr. closures
        - can omit return: `reversedNames = names.sorted(by: {s1, s2 in s1 > s2})`

    - shorthand argument names
        - use `$0`, `$1`, etc.
        - can omit arg names and `in`: `reversedNames = names.sorted(by: {$0 > $1})`

### Trailing Closures
- for longer closure expressions, when you can't write inline on single line
- write after function's call parentheses
- function call can have multiple trailing closures
```swift
func someFunction(closure: () -> Void) {}

// call without trailing closure
someFunction(closure: {
    // closure body
})

// call with trailing closure
someFunction() {
    // trailing closure body
}

// e.g. trailing closure with sorting names
reversedNames = names.sorted() { $0 > $1 }

// if it's the only argument, then () not needed
reversedNames = names.sorted { $0 > $1 }
```

- map method takes in closure expr.

- function taking multiple closures
    - omit arg label for first trailing closure, label the remaining ones
    ```swift
    // two closures: completion handler, onFailure
    func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
        if let picture = download("photo.jpg", from: server) {
            completion(picture)
        } else {
            onFailure()
        }
    }

    loadPicture(from: someServer) { picture in
        someView.currentPicture = picture
    } onFailure: {
        print("Couldn't download the next picture.")
    }
    ```

## Enumerations

### Associated Values

## Structures and Classes
### Structures and Enumerations are Value Types

## Properties

### Type Properties

## Method
#### Modifying Value Types from Within Instance Methods

### Type Methods

## Initialization
### Customizing Initialization