# R1 - Reading Assignment

## A Swift Tour

### Simple Values
- var, let
- string

### Control Flow
- for
    - for i in 0..<4 to add a range that goes from 0 to 3
    - ... to include upper value
- while
- unwrap with if let

### Functions and Closures

swift
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
- use _ to use no argument label
- can also customize arg labels, place before parameter name
- possible to return tuples
    - e.g. ... -> (min: Int, max: Int, sum: Int) {}
- nested functions can use variables declared in outer function
- functions can return functions

swift
    func makeIncrementer() -> ((Int) -> Int) {
        func addOne(number: Int) -> Int {
            return 1 + number
        }
        return addOne // returning the function, not calling it
    }
    var increment = makeIncrementer()
    increment(7)
    
- functions can also take a function as an arg
- closures: blocks of code that can be call later
    - can access vars/funcs available in scope where it was created, even if caled elsewhere
    - closure without name: surround code with ({}):

swift
            // map takes each element of numbers and applies the closure to it
            // e.g. numbers = [1, 2, 3], returns numers = [2, 4, 6]
            numbers.map({ (number: Int) -> Int in
                let result = 2 * number
                return result
            })
        
        - <mark>aside:</mark> map is a higher-order function
        - can omit params type and/or return type
            - single statement closures return the value implicitly
        - can refer to params using numbers ($0: first param, $1: second param)

### Objects and Classes

### Enumerations and Structures

### Generics

## The Basics

### Type Safety and Type Inference
- swift is type-safe
- values never implicitly converted from one type to another, but can convert explicitly
- type inference: compiler deduces type based on values given
- swift always uses Double over Float for floating point numbers

### Numeric Literals
- can write Integers as decimal (no prefix), binary (0b prefix), octal (0o prefix), hexadecimal (0x prefix)
- can use E/e for exponent with decimal
- can use P/p for exponent with hexadecimal (2^x, where x is the hexadecimal value)
- can pad ints/floats with zeros/underscores for legibility (0001.23, 1_000_000)

### Numeric Type Conversion
- Int8: -127 - 128
- UInt8: 0 - 255
- floating point to int conversion: value is truncated (3.75 -> 3)

### Tuples
- group multiple values into a single one, types don't have to be the same
- decompose tuples to use and access:

swift
    let (code, msg) = httpserror
    // can now use code and msg
    // can also access as httpserror.0, httpserror.1
    // alternatively, name tuple values so that you can reference them
    let httpserror = (statusCode: "", statMsg: "")
    // can now use httpserror.statusCode and httpserror.statMsg
    
- ignore parts of tuple with _

## Basic Operators
### Range Operators

#### Closed Range Operator

#### Half-Open Range Operator

#### One-sided Ranges

## Strings and Characters
### String Interpolation

### Counting Characters

### Accessing and Modifying a String

### Substrings

## Collection Types
### Mutability of Collections

### Arrays

### Dictionaries

## Control Flow
### Switch - no implicit fallthrough

### Break

### Early Exit

## Functions
### Function Argument Labels and Parameter Names
#### Specifying Argument Labels


### Function Types

## Closures

### Closure Expressions

### Trailing Closures

## Enumerations

### Associated Values

## Structures and Classes
### Structures and Enumerations are Value Types

## Properties

### Type Properties

## Method
#### Modifying Value Types from Within Instance Methods

### Type Methods

## Initialization
### Customizing Initialization