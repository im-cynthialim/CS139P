# R2 - Functional Programming

## A Swift Tour

### Protocols and Extensions

- use `mutating` to mark a method that modifies the struct
    - class doesn't need this cause methods in classes can always modify
- use `extension` to add methods/comp. props. to an existing type 
    ```swift

    protocol ExampleProtocol {
        var simpleDescription: String { get }
        mutating func adjust()
    }

    extension Int: ExampleProtocol {
        var simpleDescription: String {
            ...
        }
        mutating func adjust() {
            ...
        }
    }
    ```
- e.g. 
    ```swift
    // a was previously defined to be a SimpleClass instance
    let protocolValue: any ExampleProtocol = a
    print(protocolValue.simpleDescription)
    // Prints "A very simple class.  Now 100% adjusted."
    // print(protocolValue.anotherProperty)
    // ^ would give error because protocolValue is seen as an instance of ExampleProtocol, doesn't have access to a SimpleClass' anotherProperty
    ```

## The Basics

### Optionals
- use when value might be absent, mark with `?`
- `nil` is a valueless state, can assign this to optional var
    - default value of optional var is `nil`
- can't use `nil` with non-optional const/var

## Basic Operators

### Nil-Coalescing Operator
- `a ?? b` unwraps a if it has a value or returns default value of b if a is `nil`
    - `a` is always of optional type, `b` has to match this type

## Control Flow
### Conditional Statements
- value binding
    - in `switch` statements, temporarily create const/var which you can use within the respective case's body
- where
    - in `switch` case to check for additional conditions:
    ```swift
    let anotherPoint = (0,0)
    switch anotherPoint {
        case let (x,y) where x == y:
        ...
        case let (x,y) where x == -y:
        ...
    }
    ```

## Closures

### Capturing Values
- closures can "capture" consts/var from surrounding context where it's defined
    - can also refer to/modify these values even if original scope DNE anymore
- e.g. nested function
    - can use outer function's args and consts/vars defined in outer func
    - inner function captures reference to outer func's args/values (Swift might optimize this and copy value instead)

### Closures are Reference Types
- assigning a function/closure to a const/var sets that to be a reference to the func/closure
    - assigning the same closure to 2 different consts/vars will refer to the same closre

### Escaping Closures
- a closure escapes a function when the closure is passed as an argument to the func but is called after the func returns
    - use `@escaping` before func's param type to declare that closure can escape
        - closure escapes by being stored in var defined outside the function (e.g. async operation using closure arg as completion handler)
        ```swift
            var completionHandlers: [() -> Void] = []
            func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
            completionHandlers.append(completionHandler)
            }
            // func starts and returns, closure not called until after operation done
        ```
- careful: escaping closures used when `self` is an instance of a class can cause strong refernce cycles
- to capture `self`, need to write it explicitly or include in closure's capture list
    e.g. 
    ```swift
    class SomeOtherClass {
        var x = 10
        func doSomething() {
            // self included in closure's capture list
            someFunctionWithEscapingClosure { [self] in x = 100 }
            someFunctionWithNonescapingClosure { x = 200 }
        }
    }
    ```
    - this is done implicitly for non-escaping closures and if self is a struct/enum instance
- escaping closures cna't capture a mutable reference to `self` when it's an instance of a struct/enum - don't share mutability (value type = each var has own copy)

## Properties

### Computed Properties
- provide getter + optional setter to retrieve/set other properties/values`
```swift
struct Rect {
    var origin = Point()
    var size = Size()
    // center is a computed prop.
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)

            // if entire body is 1 expression, has implicit return
            // can rewrite as:
            Point(x: origin.x + ..., y: origin.y + ...)
        }
        set(newCenter) {
            // alternatively, don't need to define name "newCenter" for new value, default newValue name is used
            // e.g. origin.x = newValue.x - (size.width / 2)
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}

var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))

// center is calculated by Rect's center's getter
let initialSquareCenter = square.center
// initialSquareCenter is at (5.0, 5.0)

// use setter to update center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// Prints "square.origin is now at (10.0, 10.0)"
```

- read-only computed props. when there's only a getter
    - declare with `var`
    - can remove `get` to just have: `var volume: Double { return width * height * depth}`

## Methods

### Instance Methods
- functions that belong to instances of a particular class
- can only be called on specific instance of type it belongs to
- can use dot syntax
- its params can have both a name and arg. label

#### Assigning to self Within a Mutating Method
- `self` is equivalent to instance itself
e.g. 
```swift
func increment() {
    self.count += 1
}
```
- don't ned to write explicitly if using property/method within method
    - exception: if param name of instance method == property name of instance, param name takes precedence
e.g.
```swift
struct Point {
    var x = 0.0, y = 0.0
    func isToTheRightOf(x: Double) -> Bool {
        return self.x > x
    }
}
```

## Initialization

### Setting a Default Property Value with a Closure or Function
- use closure/function to customize default value of a property
    - will create a temp value, tailor it, then return it as the property's default value

e.g. 
```swift
class SomeClass {
    let someProperty: SomeType = {
        // create a default value for someProperty inside this closure
        // someValue must be of the same type as SomeType
        return someValue
    }()
    // empty parentheses mean to execut eclosure immediately
    // without (), saying to assign closure itself to prop. instead of return value
    // note: can't use other properties within closure - not yet initialized, even if they have default values
    // also can't use self
}
```

## Optional Chaining
- process for querying/callling properties, methods, etc. on an optional that might be `nil`

### Optional Chaining as an Alternative to Forced Unwrapping
- place `?` after optional value on which you want to call prop., method, etc. on
    - fails gracefully when optional is `nil` vs. forced unwrapping which triggers a runtime error
- result of optional chaining call is always an optional value, even if prop./method usually returns non-optional value, but will be of same type
    - can use to check if optional chaining was successful or not (would fail if `nil` in chain)
e.g. `if let roomCount = john.residence?.numberOfRooms`

## Extensions
- add new functionality to existing class, struct, enum, or protocol type
    - can do this without having access to original source code
- can:
    - add computed instance props. + computed type props
    - define instance methods + type methods
    - add new inits
    - define subscripts
    - define + use new nested types
    - make an existing type conform to a protocol
- can't override existing functionality

### Extension Syntax
- `extnesion SomeType {}`
- to adopt to 1+ protocols: `extension SomeType: SomeProtocol, AnotherProtocol {}`

### Computed Properties
- extensions can't add stored props. or property observers to existing props.
e.g.
```swift
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
print("One inch is \(oneInch) meters")
// Prints "One inch is 0.0254 meters"
```

### Initializers
- using extension to add init. that assigns default values to each stored property = can call default init within extension's init


### Methods
- can add extension that modifies instance (e.g. mutating function: `extension Int { mutating func ... {}}`)

### Subscripts
e.g.
```swift
// returns the decimal digit n places from the right
extension Int {
    subscript(digitIndex: Int) -> Int {
        var decimalBase = 1
        for _ in 0..<digitIndex {
            decimalBase *= 10
        }
        return (self / decimalBase) % 10
    }
}
```

## Protocols
- note: pretty similar to pure abstract classes in C++
- a blueprint of methods, properties, and other requirements that suit a task/functionality
    - protocol can be adopted by a class, struct. or enum. to provide actual implementation of those requirements
    - conform to protocol = type that satisfies requirements

### Protocol Syntax
- `protocol SomeProtocol`

- for types that adopt 1+ protocols: `struct SomeStructure: FirstProtocol, AnotherOne {}`

- for classes with superclass + protocols, list superclsas first: `class SomeClass: SomeSuperclass, FrstProtocol, AnotherOne {}` 

### Property Requirements
- protocols only require conforming types to have property/type with particular name + type - no specifics given on if it has to be stored/computed

- gettable and settable properties, add `{get set}`: `var newProperty: Int ( get set }`

- prefix type property requirements with `static` in protocol: `protocol AnotherOne { static var someTypeProperty: Int { get set }}`

recall: type properties are shared across all instances vs. instance property which belongs to an instance
    - use `static` to mark type property

### Method Requirements
-  can require methods to be implemented by conforming types
    - don't define with a body
    ```swift
    protocol SomeProtocol {
        static func someTypeMethod()
    }
    ```
    - variadic params allowed (i.e. extra number of args)
    - default values for methods can't be specified
    - include `static` 

### Mutating Method Requirements
- if the method will mutate the instance it belongs to, add `mutating`
    - don't tneed to write `mutating` when implementing the method for a class (only needed for strucs/enums)

### Adding Protocol Conformance with an Extension
- can extend an existing type to conform to a new protocol
    - existing instances of that type automatically conform to the protocol

- can have conditional conformance
    - add constraints when extending the type
    
    - e.g.
        ```swift
        extension Array: TextRepresentable where Element: TextRepresentable {
        var textualDescription: String {
            let itemsAsText = self.map { $0.textualDescription }
            return "[" + itemsAsText.joined(separator: ", ") + "]"
            }
        }
        let myDice = [d6, d12]
        print(myDice.textualDescription)
        ```
        - `TextRepresentable` is a protocol
        - `Array` instances only conform to `TextRepresentable` if they store elements of a type that conform to `TextRepresentable`

- if a type already conforms to a protocol, can add empty extension to make it adopt the protocol:
    ```swift
        struct Hamster {
            var textualDescription: ...
        }

        extension Hamster: TextRepresentable {}
        // TextRepresentable protocol has textualDescription property
    ```
    - can now use `Hamster` wherever `TextRepresentable` is required (this is only possible when type explicitly adopts protocol)

### Adopting a Protocol Using a Synthesized Implementation
- Swift automatically provides protocol conformance for `Equatable`, `Hashable`, `Comparable` in simple cases
- provided synthesized implmentation for `Equatable` for:
    - structs that only have stored properties that conform to `Equatable` protocol
    - enums that only have assoc. types that "
    - enums that have no assoc. types
- to set this up, declare conformance to `Equatable` in file containing original declaration - don't implement `==` operator
    -`Equatable` also provides default implementation of `!=`

- provided synthesized implmentation for `Hashable` for:
    - structs that only have stored properties that conform to `Hashable` protocol
    - enums that only have assoc. types that "
    - enums that have no assoc. types
- to set this up, declare conformance to `Hashable` in file containing original declaration without implementing `hash(into:)`

- provided syn. impl. for `Comparable` for enums that don't have a raw value
    - if enum has assoc. types, they all need to conform to `Comparable` protocol
    - for synth. impl. of `<`: declare conformance to `Comparable` protocol in file containing original enum declaration without implementing `<` yourself
    - `Conformance` provides default impl. of `<=`, `>`, and `>=`

- implicit conformance to a protocol
    - `Copyable`, `Sendable`, and `BitwiseCopyable` are all implmeented by Swift
    - can write explicitly but no difference in behaviour
        - suppress implicit conformance with:
            - `~`: `strut FileDescriptor: ~Sendable {}` - can re-add `Sendable` conformance elsewhere
            - `@available(*, unavailable)`: suppresses fully
        
### Protocol Inheritance
- protocols can inherit 1+ other protocols
    - similar syntax to class inheritance:
    ```swift
    protocol InheritingProcotol: SomeProtocol, AnotherProtocol {}

    protocol PrettyTextRep: TextRepresentable {
        var prettyTextDesc: String { get }
        // has to conform to TextRep + PrettyTextRep - needs textDesc and prettyTextDesc
    }
    ```

### Class-Only Protocols
- add `AnyObject` protocol to inheritance list: `protocol ClassProtocol: AnyObject, SomeOtherProtocol {}`
    - `ClassProtocol` can only be adopted by class types

### Protocol Extensions
- can extend protocols to provide implementations to conforming types
- these extensions can't be used to make a protocol extend/inherit from other protocols (protocol inheritance done in protocol declaration)

## Generics
- used to create abstract + reusable functions/types that can work with any type

### The Problem that Generics Solve
- allows you to avoid writing the same function over and over when behaviour's the same but types vary

### Generic Functions
e.g. generic swapping function
```swift
// Swift has a generic function swap btw
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```
- use placeholder type name (`T`)
    - shows that a and b must be of same type
    - note that generic function name followed by `<T>`

### Type Parameters
- type paremeter: specifies + names placeholder type, written right after function name (e.g. `T` is a type param)
    - replaced with actual type when function called
    - can have multiple within the `<>`, separate with commas

### Naming Type Parameters
- use descriptive names (e.g. `Dictionary<Key, Value>`) or single letters (e.g. T, U, V)

### Generic Types
- custom classes, structs, enums that work with any type, like Array + Dictionary
e.g. generic stack
```swift
struct Stack<Element> {
    var items: [Element] = []
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```

### Extending a Generic Type
- don't add type parameter list, include in body instead:
    ```swift
    extension Stack {
        var topItem: Element? {
            return items.isEmpty ? nil : items[items.count - 1]
        }
    }
    // we already know Stack has type parameter Element
    // topitem tells us it might return optional value of type Element
    ```

### Type Constraints
- specify that type param. must inherit from a specific class or conform to a particular protocol/protocol composition
    - e.g. Dictionary `Key`s have to be hashable

- syntax: place after type parameter's name, separate with colon
    - `func someFunc<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {}`
        - 2 type params: `T` and `U`
        - `T` has to be a subclass of `SomeClass`, `U` has to conform to `SomeProtocol`

e.g. find index of a value in an array
```swift
// ensure that the type T conforms to Equatable so that you can compare elements in array to value you're searching for - otherwise value == valueToFind will fail
func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {
    for (index, value) in array.enumerated() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
```

### Generic Where Clauses
- use to define requirements (like conformance to a protocol, type params and assoc. types are the same, etc.) for associated types
- use `where` followed by constraints, write right before `{` of type/func body

e.g.
```swift
func allItemsMatch<C1: Container, C2: Container>
        (_ someContainer: C1, _ anotherContainer: C2) -> Bool
        where C1.Item == C2.Item, C1.Item: Equatable {}
```
- both C1 and C2 have to conform to Container protocol
- Item type in C1 has to be the same as Item type in C2
- Item in C1 has to be Equatable (and if C1.Item == C2.Item, then C2 must also be Equatable)

### Extensions with a Generic Where Clause
e.g.
```swift
extension Stack where Element: Equatable {
    func isTop(_ item: Element) -> Bool {
        guard let topItem = items.last else {
            return false
        }
        return topItem == item
    }
}
```
- can also be used in extensions to a protocol
- can be used to require type param. to be of certain type: `extension Container where Item == Double {}`

### Contextual Where Clauses
- can use `where` clauses on different "levels" within the declaration

```swift
// instead of having to write 2 extensions separately because of the method's constraints, add it to the method

// the constraints live on the methods, "function-level" constraints
extension Container {
    func average() -> Double where Item == Int {
        var sum = 0.0
        for index in 0..<count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
     func endsWith(_ item: Item) -> Bool where Item: Equatable {
        return count >= 1 && self[count-1] == item
    }
}

// vs. 

// "extension-level" constraints
extension Container where Item == Int {
    func average() -> Double {
        var sum = 0.0
        for index in 0..<count {
            sum += Double(self[index])
        }
        return sum / Double(count)
    }
}
extension Container where Item: Equatable {
    func endsWith(_ item: Item) -> Bool {
        return count >= 1 && self[count-1] == item
    }
}

```